package thesis.bot;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;

import thesis.rmi.PotentialFunctionProvider;
import thesis.rmi.RemoteBotInterface;
import bwapi.*;
import bwta.*;

// TODO: Add more objects that generate potential fields.
/**
 * Oskari Leppäaho's master's thesis bot.
 * <p>
 * Player's own units move guided by potential fields generated by the objects
 * in the game such as enemy units and map edges. When in enemy unit range,
 * player's units will attack them if their current potential is low enough.
 * During the cooldown the units continue to move.
 * <p>
 * The game will be run in a map that resets the combat scenario after one of
 * the teams has lost all of it's units. The map will signal the bot about this
 * by setting the minerals to 500 for a moment. The bot will calculate the score
 * of the run at that point. (This might not be the best solution. It might be
 * possible also to just use game.restartGame() to restart the scenario but
 * JNIBWAPI doesn't currently support that and I'm not sure if that option skips
 * the menus. Going through the menus takes a lot of time.)
 * <p>
 * The client runs in its own thread and getRoundScore method runs in another
 * thread, polling for the flag that signals the ending of a round.
 * 
 * @author Oskari Leppäaho
 */
public class Controller extends DefaultBWListener implements Runnable,
		RemoteBotInterface {

	// TODO: Is there a reason for this to be public?
	/** Indicates if the round score for the current round has been calculated. */
	public volatile boolean isRoundResultRetrievable = false;

	/**
	 * Determines if debug information should be displayed. Enables printing
	 * potential values of the points around an unit on the game window. Also
	 * enables graphical visualizations.
	 */
	final static boolean DEBUG_INFO = false;
	/**
	 * The maximum distance of the move command from the unit position.
	 */
	final static int MOVE_DISTANCE = 1;
	/** Determines the game speed in frames per second. */
	final static int GAME_SPEED = 0;
	/**
	 * Determines the maximum length for a game (in frames). The game will be
	 * restarted if it doesn't end before the maximum number of frames has
	 * passed.
	 */
	final static int GAME_MAX_LENGTH = 1700;
	/**
	 * Determines if performance statistics should be written to two files:
	 * victories.txt and surviving_units.txt. Meant for post evolution
	 * evaluation.
	 */
	final static boolean WRITE_STATS_TO_FILE = false;
	/**
	 * The name of the bot. Will be displayed on the game window when the bot is
	 * running and in the command window as the bot is started.
	 */
	final static String BOT_NAME = "Thesis bot v5";
	/**
	 * Determines if the StarCraft client should draw the game on the screen
	 * every logical game frame. Disabling the GUI should speed the game up.
	 */
	final static boolean GUI_ON = true;
	final static int MAX_SCORE = 21150;
	/**
	 * If the notification about a round end has been registered (the map used
	 * should set minerals to 500 to notify about a round end).
	 */
	boolean hasBeenRoundEndRegistered = false;
	/**
	 * Indicates if the isStartingAttack has already changed to true after a
	 * unit has been issued an attack command. The key is the unit ID.
	 */
	HashMap<Integer, Boolean> isAttackInProgress = new HashMap<Integer, Boolean>();
	/**
	 * Used to avoid giving a move order before the attack of a unit has been
	 * finished. The key is the unit ID.
	 */
	HashMap<Integer, Boolean> hasAttackOrderBeenGiven = new HashMap<Integer, Boolean>();
	/**
	 * Holds the unit's HP value relative to group's average.
	 */
	HashMap<Unit, Double> relativeHps = new HashMap<Unit, Double>();
	/**
	 * If enabled, the game stops in every frame and only proceeds by pressing
	 * enter in the command line.
	 */
	boolean isStepThroughEnabled = false;
	// TODO: could maybe be final.
	/** BroodWar AI runs in this thread. */
	Thread bwThread;
	// TODO: Should this be volatile?
	/**
	 * Fitness for the last round. Calculated in {@link #calculateScore()}.
	 **/
	int score;

	// TODO: seems to be meaningless ATM, not read anywhere.
	/**
	 * Unused, indicates if the evolution has started (all threads have been
	 * setup).
	 */
	boolean hasEvolutionStarted = false;
	/** Indicates if the StarCraft match has started. */
	boolean hasMatchStarted = false;

	/** Draws the visualizations on the game window */
	private Visualizer visualizer;
	/** Handles potential field calculations */
	final private PotentialCalculator potentialCalculator;

	/** The BWMirror. Makes communication with BWAPI possible. */
	private Mirror mirror = new Mirror();
	/** The BroodWar game from BWMirror */
	Game game;
	List<Unit> myUnitsNoRevealers = new ArrayList<Unit>();
	List<Unit> enemyUnitsNoRevealers = new ArrayList<Unit>();
	private String name;

	/**
	 * Creates the AI client and gets results from it indefinitely.
	 * 
	 * @throws InterruptedException
	 *             If interrupted.
	 */
	public static void main(String[] args) throws InterruptedException {
		Controller client = new Controller("Default");
		int i = 1;
		while (true) {
			System.out.println("Round " + i + ". Score: "
					+ client.getRoundScore());
			++i;
		}
		// client.finish();
	}

	/**
	 * Instantiates the JNI-BWAPI interface and connects to BWAPI.
	 */
	public Controller(String name) {
		this.name = name;
		mirror.getModule().setEventListener(this);
		potentialCalculator = new PotentialCalculator(this);
		WaitForConnection();
	}

	/**
	 * Waits for StarCraft to be launched and the match to begin.
	 */
	public void WaitForConnection() {
		if (bwThread == null) {
			bwThread = new Thread(this);
			bwThread.start();
		}
		while (true) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				System.err.println("WaitForConnection of the controller was "
						+ "interrupted");
				e.printStackTrace();
			}
			if (hasMatchStarted) {
				return;
			}
		}
	}

	/**
	 * TODO: A mechanism that gives the score only after the first full round.
	 * Currently the bot will run using the default potential function until
	 * this version of the getRoundScore is called after which it will return
	 * the end score of that round event though for the beginning of the round
	 * the default potential function was used.
	 */

	/**
	 * Returns when a single round of fighting has finished. <strike>Also starts
	 * the client if it hasn't been started yet.</strike>
	 * 
	 * @param potentialProvider
	 *            The object that will provide the potential function for this
	 *            round.
	 * @return Score for the round.
	 */
	public int getRoundScore(PotentialFunctionProvider potentialProvider) {
		hasEvolutionStarted = true;
		potentialCalculator.setPotentialProvider(potentialProvider);
		while (true) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				System.err.println("Get round score waiting interrupted:");
				e.printStackTrace();
			}
			if (isRoundResultRetrievable) {
				isRoundResultRetrievable = false;
				return score;
			}
		}
	}

	/**
	 * Returns when a single round of fighting has finished. Also starts the
	 * client if it hasn't been started yet.
	 * 
	 * @return Score for the round.
	 * @throws InterruptedException
	 *             If interrupted.
	 */
	public int getRoundScore() throws InterruptedException {
		hasEvolutionStarted = true;
		// Is the starting of the thread required anymore? Looks like it is
		// already started in {@link #WaitForConnection()}.
		if (bwThread == null) {
			bwThread = new Thread(this);
			bwThread.start();
		}
		while (true) {
			Thread.sleep(100);
			if (isRoundResultRetrievable) {
				isRoundResultRetrievable = false;
				System.out.println("Max score " + MAX_SCORE);
				System.out.println("Score: " + score);
				return score;
			}
		}
	}

	/**
	 * Starts the bot.
	 */
	public void run() {
		System.out.println("Starting " + BOT_NAME);
		mirror.startGame();
	}

	/**
	 * Finishes running the games. Tells the bot to leave the game.
	 */
	public void finish() {
		bwThread.interrupt();
	}

	/**
	 * Called at the beginning of a game. Sets some options for StarCraft and
	 * gets the reference to BWMirror Game object. Also creates the visualizer.
	 */
	@Override
	public void onStart() {
		game = mirror.getGame();
		visualizer = new Visualizer(game, this, DEBUG_INFO);

		final int ENABLECODE_PERFECT_INFORMATION = 0;
		// final int ENABLECODE_USER_INPUT = 1;

		// game.enableFlag(ENABLECODE_USER_INPUT);
		game.enableFlag(ENABLECODE_PERFECT_INFORMATION);
		game.setLocalSpeed(GAME_SPEED);

		if (!GUI_ON)
			game.setGUI(false);
		hasMatchStarted = true;

		hasBeenRoundEndRegistered = false;

		isAttackInProgress.clear();
		hasAttackOrderBeenGiven.clear();
		relativeHps.clear();

		BWTA.readMap();
		BWTA.analyze();
	}

	/**
	 * Called each game cycle. Handles stepping frame by frame and leaving the
	 * game when requested. Draws the name of the bot on the screen and
	 * highlights the units. Then loops AI player's units giving them orders.
	 */
	@Override
	public void onFrame() {
		cacheVariables();
		populateUnitHashMaps();
		cacheRelativeHps();

		// Comment: tried to wait for the first request from evolution
		// while (!isStarted) {
		// try {
		// Thread.sleep(1000);
		// System.out.println("Waiting for the first score request");
		// } catch (InterruptedException e) {
		// System.err.println("Match frame interrupted while waiting"
		// + " for start signal");
		// e.printStackTrace();
		// }
		// }
		// --------------debug
		// System.out.println("Frame " + bwapi.getFrameCount());
		// -------------enddebug
		if (isStepThroughEnabled) {
			waitForEnterOnConsole();
		}
		if (Thread.currentThread().isInterrupted()) {
			game.leaveGame();
		}
		game.drawTextScreen(0, 20, BOT_NAME);
		game.drawTextScreen(0, 30, "" + game.getFrameCount());
		checkForRoundEnd();
		visualizer.highlightUnits();
		for (Unit u : myUnitsNoRevealers) {
			handleUnit(u);
		}
	}

	private void cacheRelativeHps() {
		double averageRelativeHpLeft = 0;
		double hpLeft = 0;
		double maxHp = 0;
		for (Unit u : getMyUnitsNoRevealers()) {
			hpLeft = 0;
			maxHp = 0;
			hpLeft += u.getHitPoints();
			hpLeft += u.getShields();
			maxHp += u.getType().maxHitPoints();
			maxHp += u.getType().maxShields();
			averageRelativeHpLeft += hpLeft / maxHp;
		}
		averageRelativeHpLeft /= getMyUnitsNoRevealers().size();
		for (Entry<Unit, Double> entry : relativeHps.entrySet()) {
			hpLeft = 0;
			maxHp = 0;
			hpLeft += entry.getKey().getHitPoints();
			hpLeft += entry.getKey().getShields();
			maxHp += entry.getKey().getType().maxHitPoints();
			maxHp += entry.getKey().getType().maxShields();
			entry.setValue((hpLeft / maxHp) / averageRelativeHpLeft);
		}
	}

	public double getRelativeHp(Unit u) {
		return relativeHps.get(u);
	}

	/**
	 * Caches the lists of own and enemy units to avoid calls to BWAPI.
	 */
	private void cacheVariables() {
		myUnitsNoRevealers = removeRevealersFromUnitSet(game.self().getUnits());
		enemyUnitsNoRevealers = removeRevealersFromUnitSet(game.enemy()
				.getUnits());
	}

	/**
	 * Checks if the HashMaps containing information about the units' attack
	 * states have been filled for the AI player's units and fills them if they
	 * are empty.
	 */
	private void populateUnitHashMaps() {
		if (hasAttackOrderBeenGiven.isEmpty())
			for (Unit u : getMyUnitsNoRevealers())
				hasAttackOrderBeenGiven.put(u.getID(), false);

		if (isAttackInProgress.isEmpty())
			for (Unit u : getMyUnitsNoRevealers())
				isAttackInProgress.put(u.getID(), false);

		if (relativeHps.isEmpty())
			for (Unit u : getMyUnitsNoRevealers())
				relativeHps.put(u, 1d);
	}

	/**
	 * Waits for the user to press enter on the console.
	 */
	private void waitForEnterOnConsole() {
		try {
			System.in.read();
		} catch (IOException e) {
			System.err.println("Something went wrong when waiting for \n"
					+ "the user to press enter on the console\n"
					+ "(for stepping).");
			e.printStackTrace();
		}
	}

	/**
	 * Check if a round has ended. Handle round ending: set and reset
	 * appropriate flags for the new round and calculate the score. The map
	 * should signal about an end of round by setting the AI player's minerals
	 * to 500. At the start of a new round the minerals will be reset to 0.
	 */
	private void checkForRoundEnd() {
		// It takes one frame to enable the perfect information flag so the
		// enemy units can't be seen in the first frame. If we called
		// checkForRoundEnd in the first frame, it would think that the enemy
		// has been defeated.
		if (game.getFrameCount() == 0)
			return;
		if (!isRoundResultRetrievable
				&& !hasBeenRoundEndRegistered
				&& ((getMyUnitsNoRevealers().size() == 0 || getEnemyUnitsNoRevealers()
						.size() == 0) || game.getFrameCount() > GAME_MAX_LENGTH)) {
			hasBeenRoundEndRegistered = true;
			isRoundResultRetrievable = true;

			isStepThroughEnabled = false;

			calculateScore();
		}

		// This means that the round has ended and the round result has been
		// retrieved. Time to start a new round.
		if (hasBeenRoundEndRegistered && !isRoundResultRetrievable
				&& hasMatchStarted) {
			game.restartGame();
			hasMatchStarted = false;
		}
	}

	/**
	 * Calculates the score for this round. The score is calculated by adding
	 * shields and hit points of remaining friendly units and subtracting the
	 * shields and hit points of remaining enemy units.
	 */
	private void calculateScore() {
		score = 0;
		score += game.self().getUnitScore();
		score += game.self().getKillScore();
		score -= game.enemy().getKillScore();
		int totalOwnHitpointsShieldsLeft = 0;
		if (!(game.getFrameCount() > GAME_MAX_LENGTH)) {
			totalOwnHitpointsShieldsLeft = 0;
			for (Unit u : game.self().getUnits()) {
				totalOwnHitpointsShieldsLeft += u.getShields();
				totalOwnHitpointsShieldsLeft += u.getHitPoints();
			}
			totalOwnHitpointsShieldsLeft *= 10;
			score += totalOwnHitpointsShieldsLeft;
		} else {
			if (game.self().getKillScore() > 0)
				appendToFile("endlogs" + File.separator + name + ".txt",
						"Framecount: " + game.getFrameCount() + " Own units: "
								+ getMyUnitsNoRevealers().size()
								+ " Enemy units: "
								+ getEnemyUnitsNoRevealers().size());
		}
		// System.out.println("Unit score: " + game.self().getUnitScore() +
		// " Enemy kill score: " + game.enemy().getKillScore());
		// System.out.println("Own unit count: " +
		// getMyUnitsNoRevealers().size() + " Enemy unit count: " +
		// getEnemyUnitsNoRevealers().size());
		// System.out.println("TotalOwnHitpointsShieldsLeft: " +
		// totalOwnHitpointsShieldsLeft);
		// System.out.println("Score: " + score);
		score -= MAX_SCORE;
		score *= -1;
		System.out.println("End frames: " + game.getFrameCount());
		if (WRITE_STATS_TO_FILE)
			writeStatsToFile();
	}

	/**
	 * Writes performance statistics to two files: victories.txt and
	 * surviving_units.txt. Meant for post evolution evaluation.
	 */
	private void writeStatsToFile() {
		appendToFile("victories.txt",
				(getEnemyUnitsNoRevealers().size() < getMyUnitsNoRevealers()
						.size()) ? "1" : "0");
		appendToFile(
				"surviving_units.txt",
				(" Own: " + getMyUnitsNoRevealers().size() + " Enemy: " + getEnemyUnitsNoRevealers()
						.size()));
		appendToFile("scores.txt", "" + score);
	}

	/**
	 * Appends a line of text to a file.
	 * 
	 * @param filePath
	 *            Path to the file.
	 * @param line
	 *            The line to append.
	 */
	private void appendToFile(String filePath, String line) {
		try (PrintWriter out = new PrintWriter(new BufferedWriter(
				new FileWriter(filePath, true)))) {
			out.println(line);
		} catch (IOException e) {
			System.out.println("Error when printing to myfile.txt: "
					+ e.getMessage());
		}
	}

	/**
	 * Return a list of my units. Ignore map revealers.
	 * 
	 * @return A list of my units without map revealers.
	 */
	public List<Unit> getMyUnitsNoRevealers() {
		return myUnitsNoRevealers;
	}

	/**
	 * Return a list of enemy units. Ignore map revealers.
	 * 
	 * @return A list of enemy units without map revealers.
	 */
	public List<Unit> getEnemyUnitsNoRevealers() {
		return enemyUnitsNoRevealers;
	}

	/**
	 * Removes map revealer units from a list of units.
	 * 
	 * @param unitList
	 *            Unit list to remove map revealers from.
	 * @return Unit list with map revealers removed.
	 */
	private List<Unit> removeRevealersFromUnitSet(List<Unit> unitList) {
		List<Unit> units = new ArrayList<Unit>();
		for (Unit unit : unitList) {
			if (unit.getType() != UnitType.Terran_SCV)
				units.add(unit);
		}
		return units;
	}

	/**
	 * Should be Called in each game cycle for every unit. Controls the AI
	 * player's units. If some enemy units are in range and the current
	 * potential is large enough (the unit is fairly comfortable with its
	 * current position), the unit will shoot at some enemy unit that is in
	 * range. Any move orders won't be given before an attack has finished. When
	 * not attacking, moves the units based on each unit's potential fields.
	 * 
	 * @param u
	 *            The unit to be handled.
	 */
	private void handleUnit(Unit u) {
		Position moveTo = null;
		try {
			double currentPotential;
			double[] potentials = potentialCalculator.getPotentialsAround(u);
			Position moveDirection = potentialCalculator
					.getMoveDirection(potentials);
			visualizer.drawPotentialValues(potentials);
			if (isAttacking(u)) {
				return;
			}
			currentPotential = potentialCalculator.getPotential(
					u.getPosition(), u);
			if (u.getGroundWeaponCooldown() == 0 && currentPotential > 0) {
				if (attackFirstEnemy(u)) {
					return;
				}
			}
			moveTo = potentialCalculator.getHighestPotentialPosition(
					u.getPosition(), moveDirection, MOVE_DISTANCE, u);

			// Moving this much past the point where we want to actually be.
			// Unit acceleration and breaking causes it to lag behind the
			// position of the move command given.
			u.move(offsetPosition(moveTo, moveDirection, 20), false);
		} finally {
			visualizer.visualizeDestination(u, moveTo,
					getHasAttackOrderBeenGiven(u) || getIsAttackInProgress(u));
		}
	}

	/**
	 * Indicates if a unit has been issued an attack command and hasn't finished
	 * attacking.
	 * 
	 * @param u
	 *            Unit to check.
	 * @return True if the unit has been issued an attack command and it hasn't
	 *         finished attacking.
	 */
	private boolean isAttacking(Unit u) {
		/*
		 * After the unit has been issued an attack order it takes a few frames
		 * before its state is isStartingAttack. The order of the unit will
		 * however change immediately. But the order won't change after the
		 * attack has ended. attackInProgress tells if the isStartingAttack has
		 * already changed to true. The attack ends when isAttackFrame and
		 * isStartingAttack are false but attackInProgress is yet true so then
		 * attackInProgress will be set to false.
		 */

		// System.out.println("AttackCheck: "
		// + (u.isAttackFrame() || u.isStartingAttack() || (!attackInProgress &&
		// u.getOrder() == OrderType.OrderTypes.AttackUnit))
		// + " isAttackFrame: " + u.isAttackFrame() + " isStartingAttack: "
		// + u.isStartingAttack() + " attackInProgress: " + attackInProgress
		// + " orderType: " + u.getOrder().getName());
		// //+ " orderIsAttack: " + (u.getOrder() ==
		// OrderType.OrderTypes.AttackUnit));
		// if( u.isAttackFrame() || u.isStartingAttack() || (!attackInProgress
		// && u.getOrder() == OrderType.OrderTypes.AttackUnit)) {

		if (u.isAttackFrame() || u.isStartingAttack()
				|| (!getIsAttackInProgress(u) && getHasAttackOrderBeenGiven(u))) {
			// Attack order has been given and attack hasn't finished yet.
			if (!getIsAttackInProgress(u) && (u.isStartingAttack())) {
				// First frame of the actual attack.
				isAttackInProgress.put(u.getID(), true);
				hasAttackOrderBeenGiven.put(u.getID(), false);
			}
			return true;
		} else if (getIsAttackInProgress(u)) {
			// First frame after the attack.
			isAttackInProgress.put(u.getID(), false);
		}

		// No attacking in progress.
		return false;
	}

	/**
	 * Indicates if the unit has an attack in progress.
	 * 
	 * @param u
	 *            The unit to check.
	 * @return True if the unit has an attack in progress.
	 */
	private boolean getIsAttackInProgress(Unit u) {
		return isAttackInProgress.get(u.getID()).booleanValue();
	}

	/**
	 * Indicates if the unit has been given an attack order.
	 * 
	 * @param u
	 *            The unit to check.
	 * @return True if the unit has been given an attack order.
	 */
	private boolean getHasAttackOrderBeenGiven(Unit u) {
		return hasAttackOrderBeenGiven.get(u.getID()).booleanValue();
	}

	/**
	 * Orders the given unit to attack the first enemy unit that is in its
	 * ground weapon's range.
	 * 
	 * @param u
	 *            The unit that will be given the attack order.
	 * @return If an enemy was found in range and was attacked.
	 */
	private boolean attackFirstEnemy(Unit u) {
		boolean attack = false;

		for (Unit eu : getEnemyUnitsNoRevealers()) {
			if (u.isInWeaponRange(eu)) {
				hasAttackOrderBeenGiven.put(u.getID(), true);
				u.attack(eu, false);
				attack = true;
				visualizer.setAttackTarget(u, eu);
			}
		}
		return attack;
	}

	/**
	 * Adds direction * distance to position.
	 * 
	 * @param position
	 *            Position to add to.
	 * @param direction
	 *            Direction to add. X and Y must be in [-1, 1]
	 * @param distance
	 *            Distance to add
	 * @return Position + direction * distance
	 * 
	 */
	Position offsetPosition(Position position, Position direction, int distance) {
		if (direction.getX() < -1 || 1 < direction.getX()
				|| direction.getY() < -1 || 1 < direction.getY())
			throw new IllegalArgumentException(
					"Illegal argument direction in offsetPosition: "
							+ direction);
		if ((direction.getX() * direction.getX() + direction.getY()
				* direction.getY()) == 2) {
			distance = (int) (distance / Math.sqrt(2.0));
		}
		Position overMoveVector = new Position((int) Math.round((direction
				.getX() * distance)),
				(int) Math.round((direction.getY() * distance)));

		Position newPosition = PosUtils.add(position, overMoveVector);
		return newPosition;
	}

	/**
	 * Finds the highest index in an array of doubles. If there are multiple
	 * highest values and the one in index 4 is one of them, default to index 4.
	 * 
	 * @param array
	 *            An array of doubles.
	 * @return The index of the highest value. Default to index 4.
	 */
	static int findHighestDefaultTo4(double[] array) {
		int highestIndex = findHighest(array);
		if (array[highestIndex] == array[4])
			highestIndex = 4;
		return highestIndex;
	}

	/**
	 * Find the index of the highest value in a array of doubles.
	 * 
	 * @param array
	 *            An array of doubles.
	 * @return The index of the highest value.
	 */
	private static int findHighest(double[] array) {
		double highest = array[0];
		int highestIndex = 0;
		for (int i = 0; i < array.length; i++) {
			if (highest < array[i]) {
				highest = array[i];
				highestIndex = i;
			}
		}
		return highestIndex;
	}

	@Override
	public void onUnitDestroy(Unit unit) {
		isAttackInProgress.remove(unit.getID());
		hasAttackOrderBeenGiven.remove(unit.getID());
		relativeHps.remove(unit);
	}
}
